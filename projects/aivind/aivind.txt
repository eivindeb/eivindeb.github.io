In my third year of university I took my first AI-course. I wanted to learn more about the AI-algorithms presented in the course, and also develop my coding skills. I therefore embarked on a quest to design and implement my own chess AI, aptly named AIvind. On this page you can play versus a webified version of AIvind the chess engine, see if you can beat the digital me!

The chess AI project was a fun, instructive, and challenging project, both from an AI-theoretic standpoint but also from a coding implementation perspective. I started implementing the engine in Python, but quickly realized that I needed more raw speed. I therefore switched to the c++ language, and employed clever board and move representations combined with bit manipulations to make the main logic loops of the code run faster, thus allowing more calculations in a given time frame resulting in stronger play! The engine totals some 4000 lines of c++ code, and gave me valuable experience in working with large software projects with many interacting parts, where code optimization is also an important aspect to yield a stronger engine.

In terms of AI-algorithms AIvind is a minimax tree search engine, primarily consisting of one component that generates the search tree of possible moves a given number of moves a head in time, and an evaluator that assigns a "goodness" score to a given board position, similar to the structure of the Stockfish engine. In essence, the engine generates the possible board positions that make up the tree of possible future board positions and evaluates each to find the move that given optimal play from the opponent will result in the best future board position for the engine. Of course, here as well there are several extensions to the basic algorithm that were interesting to learn and think about and to implement. These include alpha-beta pruning (a lossless algorithm to prune parts of the search space that cant possibly contain a better move than the current best one), quiescence search (when a search path ends with an unstable position, e.g. immediate trade options or checks, these moves are explored further as the evaluation is likely to significantly change as a result of these moves), and transposition tables (a given position can be arrived at from differing sequences of moves, called transpositions, hashing the evaluation results of board positions can then be used to speed up future searching when these previously evaluated positions are encountered again).